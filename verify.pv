free c : channel .
type ByteVec.
type message1.
type message3.
type message2.
type host.
type nonce.
type pkey.
type skey.
type spkey.
type sskey.

fun nonce_to_bitstring(nonce): bitstring [data,typeConverter].

(* Public key encryption *)

fun pk(skey): pkey.
fun encrypt(bitstring, pkey): bitstring.
reduc forall x: bitstring, y: skey; decrypt(encrypt(x,pk(y)),y) = x.

(* Signatures *)

fun spk(sskey): spkey.
fun sign(bitstring, sskey): bitstring.
reduc forall m: bitstring, k: sskey; getmess(sign(m,k)) = m.
reduc forall m: bitstring, k: sskey; checksign(sign(m,k), spk(k)) = m.

(* Shared key encryption *)

fun sencrypt(bitstring,nonce): bitstring.
reduc forall x: bitstring, y: nonce; sdecrypt(sencrypt(x,y),y) = x.

fun aenc(bitstring,pkey):bitstring.
reduc forall x:bitstring,y:skey;adec(aenc(x,pk(y)),y)=x.

free Na,Nb: bitstring [private].
query secret nonceA;
      secret nonceB.
event Bob_State_1().
event Verify_State_1().
event Alice_State_1().
event beginBparam(pkey).
event endBparam(pkey).
event beginAparam(pkey).
event endAparam(pkey).

let Alice()=
let Bob()=
let processA(pkB: pkey, skA: skey) =
	in(c, pkX: pkey);
	event beginBparam(pkX); 
	new Na: bitstring; 
	out(c, aenc((Na, pk(skA)), pkX));
	in(c, m: bitstring); 
	let (=Na, NX: bitstring) = adec(m, skA) in
	out(c, aenc(NX, pkX));
	if pkX = pkB  then
	event endAparam(pk(skA));
	let NaA = Na in
	let NbA = NX.

let processB(pkA: pkey, skB: skey) =
	in(c, m: bitstring);
	let (NY: bitstring, pkY: pkey) = adec(m, skB) in
	event beginAparam(pkY);
	new Nb: bitstring;
	out(c, aenc((NY, Nb), pkY));
	in(c, m3: bitstring);
	if Nb = adec(m3, skB) then
	if pkY = pkA then
	event endBparam(pk(skB));
	let nonceA = NY in
	let nonceB = Nb.

process 
	new skA: skey; let pkA = pk(skA) in out(c, pkA);
	new skB: skey; let pkB = pk(skB) in out(c, pkB);
( (!processA(pkB, skA)) | (!processB(pkA, skB)) )